Шпаргалка по файлу postgresql.conf

Смотрим где лежит файт postgresql.conf

SHOW config_file; 

Чтобы посмотреть текущее значение параметра можем использовать
show <имя_параметра>;

Запрос
select * from pg_file_settings;
Представление показывает содержимое файла postgresql.conf но без комментариев и только те параметры, которые включены. Поле applied показывает будет ли применено значение, если перечитать файл. false - в том случае, если изменения не подхватятся обычным перечитыванием, нужно будет перезапускать сервер, или такой параметр есть ниже в таблице - применяется последний.

Если меняем параметры, то нужно перечитать файл конфигурации, вызвав команду:

select pg_reload_conf();
или в терминале
pg_ctl reload 
или
pg_ctlcluster 16 main reload (16 - номер версии, main - имя кластера)

Некоторые параметры требуют перезапуска сервера.

Как понять, какой параметр и когда будет применим, используем запрос:
select * from pg_settings;

Поле context показывает Поле context - показывает когда применится параметр и кто имеет право его менять. Всего 7 типов context:

1. internal (Внутренний)
Что это: Значения, которые определяются при компиляции PostgreSQL или жестко заданы платформой.
Как менять: Никак. Вообще. Даже если очень хочется. Часто это версии протоколов, размеры блоков и т.д.
Пример: block_size (обычно 8kB). Чтобы его изменить, нужно пересобирать PostgreSQL из исходного кода.

2. postmaster (Главный процесс)
Смысл: Это параметры, которые нужны серверу до того, как он начнет полноценную работу. Обычно это выделение оперативной памяти (Shared Memory) или открытие сетевых портов.
Как менять:
Изменить в postgresql.conf.
Сделать полный рестарт сервера (systemctl restart postgresql или pg_ctl restart). Просто reload не поможет — сервер напишет в логах, что видит изменение, но не может его применить без перезагрузки.
Аналогия: Это как фундамент дома. Нельзя поменять фундамент, пока в доме живут люди. Нужно всех выселить и перестроить.
Примеры: shared_buffers (память), port (сетевой порт).

3. sighup (Сигнал HUP)
Смысл: Названо в честь Unix-сигнала SIGHUP (Signal Hang Up), который исторически говорил процессам "перечитай конфигурацию".
Как менять:
Изменить в файле.
Сделать reload (перечитывание). Это можно сделать командой SQL SELECT pg_reload_conf(); или из консоли pg_ctl reload.
Сервер не останавливается, соединения пользователей не разрываются.
Аналогия: Это как сменить музыку на вечеринке. Вечеринка продолжается, просто правила (песня) изменились.
Примеры: log_min_duration_statement (настройка логирования медленных запросов), max_wal_size.

4. backend (Процесс обслуживания)
Смысл: Параметр применяется при создании нового подключения (сессии).
Тонкость: Если ты поменял параметр в файле и сделал reload:
У тех, кто уже подключен — останется старое значение.
У тех, кто подключится после релоада — будет новое значение.
Примеры: log_connections (логировать ли факт подключения).

5. superuser (Только админ)
Смысл: Параметры, которые можно менять прямо на лету (внутри SQL-сессии) командой SET, но делать это может только пользователь с правами суперпользователя (postgres).
Влияние: Обычно влияет только на текущую сессию, если делать через SET. Либо на всех, если менять в файле конфигурации.
Примеры: fsync (отключение синхронизации с диском — опасно, поэтому только для суперюзера).

6. user (Пользовательский)
Смысл: Самые "легкие" параметры. Любой пользователь может изменить их для себя прямо во время работы.
Как менять: Командой SET parameter_name = value;.
Примеры: work_mem (память для сортировки), search_path.

7. superuser-backend
Смысл: Это гибрид. Эти параметры может менять только суперпользователь (как superuser), но их изменение влияет только на новые соединения (как backend).
Почему так сложно: Эти параметры часто связаны с настройкой окружения для сессии, которые обычный пользователь не должен трогать, но и рестартить сервер ради них глупо. Однако поменять их "на лету" внутри уже идущей транзакции или сессии нельзя — слишком поздно. Их нужно задавать в конфиг-файле, делать reload, и они применятся для всех, кто зайдет после.
Пример: session_preload_libraries (библиотеки, которые подгружаются при старте сессии). Обычный юзер не должен грузить что попало, но и сервер рестартить ради одной библиотеки не хочется.


Как менять параметры:

1.. Поменять параметр в самом файле postgresql.conf - открыть обычным редактором и заменить. Перечитать файл или перезапустить сервер

2. Через  ALTER SYSTEM SET, внося изменения в файл postgresql.auto.conf, который читается после основного файла настроек
примеры команд: 
	ALTER SYSTEM SET shared_buffers = '2GB';  -- устанавливает параметр
	ALTER SYSTEM RESET shared_buffers; -- сбрасывает параметр
	ALTER SYSTEM RESET ALL; -- сбрасывает все параметры
	
3. Изменение параметров на уровне сессии (SET) - влияет только на текущую сессию (подключение) - параметр будет хранится в памяти серверного backend-процесса
примеры команд: 
	SET work_mem = '64MB'; -- установить параметр
	RESET work_mem; -- сбросить параметр
Можно менять параметры где context=user или superuser

4. Изменение параметров на уровне роли и базы данных - это постоянные настройки, но приоритетнее, чем postgresql.conf.

Параметры на уровне базы:
ALTER DATABASE mydb
SET work_mem = '64MB'; - Что это значит: любой пользователь, который подключится к mydb получит work_mem = 64MB по умолчанию

Проверка:
SHOW work_mem;

Параметры на уровне роли:
ALTER ROLE app_user
SET statement_timeout = '5s'; - Что это значит: при подключении этого пользователя к любой базе в кластере будет statement_timeout = 5s

Комбинация  роль + база:
ALTER ROLE app_user IN DATABASE mydb
SET work_mem = '128MB'; - Это самый высокий приоритет среди постоянных настроек.

Где физически хранятся эти параметры из п.4

Они хранятся в системных каталогах PostgreSQL:

pg_database.datconfig
pg_roles.rolconfig

Посмотреть можно так:

SELECT datname, datconfig
FROM pg_database
WHERE datname = 'mydb';

SELECT rolname, rolconfig
FROM pg_roles
WHERE rolname = 'app_user';

Как сбросить:
ALTER DATABASE mydb RESET work_mem;
ALTER ROLE app_user RESET statement_timeout;

или всё сразу:
ALTER ROLE app_user RESET ALL;
